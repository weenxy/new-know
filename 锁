锁的本质
NSLock是基于 POSIX threads 实现的，而 POSIX threads 中使用互斥量同步线程。

互斥量（或称为互斥锁）是 pthread 库为解决这个问题提供的一个基本的机制。互斥量是一个锁，它保证如下三件事情：
原子性 - 锁住一个互斥量是一个原子操作，表明操作系统保证如果在你已经锁了一个互斥量，那么在同一时刻就不会有其他线程能够锁住这个互斥量；
奇异性 - 如果一个线程锁住了一个互斥量，那么可以保证的是在该线程释放这个锁之前没有其他线程可以锁住这个互斥量；
非忙等待 - 如果一个线程（线程1）尝试去锁住一个由线程2锁住的锁，线程1会挂起（suspend）并且不会消耗任何CPU资源，直到线程2释放了这个锁。这时，线程1会唤醒并继续执行，锁住这个互斥量。

锁的分类
互斥锁(Mutex)
常用，当一个线程试图获取被另一个线程占用的锁时，它就会被挂起，让出CPU，直到该锁被释放。
@synchronized：实现单例模式
NSLock：不能迭代加锁，如果发生两次lock，而未unlock过，则会产生死锁问题。

递归锁(Recursive Lock)
递归锁可以被同一线程多次请求，而不会引起死锁，即在多次被同一个线程进行加锁时，不会造成死锁。这主要是用在循环或递归操作中。
可以允许同一线程多次加锁，而不会造成死锁。
递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。

自旋锁(Spin Lock)
自旋锁是非阻塞的，当一个线程无法获取自旋锁时，会自旋，直到该锁被释放，等待的过程中线程并不会挂起。
优点：效率高，不用进行线程的切换
缺点：如果一个线程霸占锁的时间过长，自旋会消耗CPU

信号量(Semaphore）
Dispatch Semaphore是持有计数的信号，该计数是多线程编程中的计数类型信号。计数为0时等待，计数大于等于1时，减1为不等待。
